<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Metaballs in WebGL - Full Example</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        }
        
        canvas {
            width: 800px;
            height: 800px;
            display: block;
            background-color:#207DCA;
        }

        #controls-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            color: white;
            width: 300px;
            max-height: 90vh;
            overflow-y: auto;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }

        .control-group {
            margin-bottom: 20px;
            padding: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 5px;
        }

        .control-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .toggle-slider {
            background-color: #2196F3;
        }

        input:checked + .toggle-slider:before {
            transform: translateX(26px);
        }

        .slider-container {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .range-slider {
            width: 100%;
            margin: 10px 0;
        }

        .slider-value {
            font-size: 0.8em;
            color: #aaa;
        }

        .color-picker-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
        }

        .color-picker {
            -webkit-appearance: none;
            width: 50px;
            height: 30px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        .color-picker::-webkit-color-swatch-wrapper {
            padding: 0;
        }

        .color-picker::-webkit-color-swatch {
            border: none;
            border-radius: 5px;
        }

        /* Add styles for the force type selector */
        .force-type-selector {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            gap: 10px;
        }

        .force-type-button {
            flex: 1;
            padding: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .force-type-button.active {
            background: #2196F3;
            border-color: #2196F3;
        }
    </style>
</head>
<body>
    <canvas id="glcanvas" width="500" height="500"></canvas>
    
    <div id="controls-panel">
        <h3 style="margin-top: 0;">Effect Controls</h3>
        
        <!-- Color Controls -->
        <div class="control-group">
            <h4 style="margin-top: 0;">Color Settings</h4>
            
            <!-- Base Color -->
            <div class="control-header">
                <span>Base Color</span>
                <div class="color-picker-container">
                    <input type="color" id="base-color" class="color-picker" value="#FFFFFF">
                </div>
            </div>

            <!-- Secondary Color -->
            <div class="control-header">
                <span>Secondary Color</span>
                <div class="color-picker-container">
                    <input type="color" id="secondary-color" class="color-picker" value="#88CCFF">
                </div>
            </div>

            <!-- Background Color -->
            <div class="control-header">
                <span>Background Color</span>
                <div class="color-picker-container">
                    <input type="color" id="background-color" class="color-picker" value="#207DCA">
                </div>
            </div>

            <!-- Velocity Color Effect -->
            <div class="control-header">
                <span>Velocity Color</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="velocity-color-toggle">
                    <span class="toggle-slider"></span>
                </label>
            </div>
            <div class="slider-container">
                <input type="range" id="velocity-color-slider" class="range-slider" 
                       min="0.1" max="2.0" step="0.1" value="1.0">
                <span class="slider-value">Intensity: <span id="velocity-color-value">1.0</span></span>
            </div>

            <!-- Distance Color Effect -->
            <div class="control-header">
                <span>Distance Blend</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="distance-color-toggle">
                    <span class="toggle-slider"></span>
                </label>
            </div>
            <div class="slider-container">
                <input type="range" id="distance-color-slider" class="range-slider" 
                       min="0.1" max="2.0" step="0.1" value="1.0">
                <span class="slider-value">Blend: <span id="distance-color-value">1.0</span></span>
            </div>
        </div>

        <!-- Mouse Interaction -->
        <div class="control-group">
            <h4 style="margin-top: 0;">Mouse Interaction</h4>
            
            <!-- Mouse Force Toggle -->
            <div class="control-header">
                <span>Mouse Force</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="mouse-force-toggle">
                    <span class="toggle-slider"></span>
                </label>
            </div>

            <!-- Force Type Selector -->
            <div class="force-type-selector">
                <button id="attract-button" class="force-type-button active">Attract</button>
                <button id="repel-button" class="force-type-button">Repel</button>
            </div>

            <!-- Force Strength -->
            <div class="slider-container">
                <input type="range" id="mouse-force-slider" class="range-slider" 
                       min="0.1" max="2.0" step="0.1" value="1.0">
                <span class="slider-value">Force: <span id="mouse-force-value">1.0</span></span>
            </div>

            <!-- Effect Radius -->
            <div class="slider-container">
                <input type="range" id="mouse-radius-slider" class="range-slider" 
                       min="50" max="300" step="10" value="150">
                <span class="slider-value">Radius: <span id="mouse-radius-value">150</span>px</span>
            </div>
        </div>

        <!-- Viscous Damping -->
        <div class="control-group">
            <div class="control-header">
                <span>Viscous Damping</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="viscous-damping-toggle">
                    <span class="toggle-slider"></span>
                </label>
            </div>
            <div class="slider-container">
                <input type="range" id="viscous-damping-slider" class="range-slider" 
                       min="0.8" max="0.99" step="0.01" value="0.90">
                <span class="slider-value">Strength: <span id="viscous-damping-value">0.90000</span></span>
            </div>
        </div>

        <!-- Vorticity -->
        <div class="control-group">
            <div class="control-header">
                <span>Vorticity</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="vorticity-toggle">
                    <span class="toggle-slider"></span>
                </label>
            </div>
            <div class="slider-container">
                <input type="range" id="vorticity-slider" class="range-slider" 
                       min="0.1" max="2.0" step="0.1" value="0.9">
                <span class="slider-value">Strength: <span id="vorticity-value">0.9</span></span>
            </div>
        </div>

        <!-- Turbulence -->
        <div class="control-group">
            <div class="control-header">
                <span>Turbulence</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="turbulence-toggle">
                    <span class="toggle-slider"></span>
                </label>
            </div>
            <div class="slider-container">
                <input type="range" id="turbulence-slider" class="range-slider" 
                       min="0.1" max="1.0" step="0.1" value="0.5">
                <span class="slider-value">Strength: <span id="turbulence-value">0.5</span></span>
            </div>
        </div>

        <!-- Angular Momentum -->
        <div class="control-group">
            <div class="control-header">
                <span>Angular Momentum</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="angular-momentum-toggle">
                    <span class="toggle-slider"></span>
                </label>
            </div>
            <div class="slider-container">
                <input type="range" id="angular-momentum-slider" class="range-slider" 
                       min="0.00001" max="0.0001" step="0.00001" value="0.00002">
                <span class="slider-value">Strength: <span id="angular-momentum-value">0.0000</span></span>
            </div>
        </div>

        <!-- Surface Tension -->
        <div class="control-group">
            <div class="control-header">
                <span>Surface Tension</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="surface-tension-toggle">
                    <span class="toggle-slider"></span>
                </label>
            </div>
            <div class="slider-container">
                <input type="range" id="surface-tension-slider" class="range-slider" 
                       min="0.01" max="0.1" step="0.01" value="0.03">
                <span class="slider-value">Strength: <span id="surface-tension-value">0.03</span></span>
            </div>
        </div>

        <!-- Add after Surface Tension control group -->
        <!-- Gravity Control -->
        <div class="control-group">
            <div class="control-header">
                <span>Gravity</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="gravity-toggle" checked>
                    <span class="toggle-slider"></span>
                </label>
            </div>
            <div class="slider-container">
                <input type="range" id="gravity-slider" class="range-slider" 
                       min="0.0001" max="0.002" step="0.0001" value="0.0005">
                <span class="slider-value">Strength: <span id="gravity-value">0.0005</span></span>
            </div>
        </div>

        <!-- Repulsion Controls -->
        <div class="control-group">
            <div class="control-header">
                <span>Ball Repulsion</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="repulsion-toggle" checked>
                    <span class="toggle-slider"></span>
                </label>
            </div>
            <div class="slider-container">
                <input type="range" id="repulsion-slider" class="range-slider" 
                       min="0.0" max="0.05" step="0.005" value="0.02">
                <span class="slider-value">Strength: <span id="repulsion-value">0.02</span></span>
            </div>
            <div class="slider-container">
                <input type="range" id="repulsion-radius-slider" class="range-slider" 
                       min="0.1" max="0.5" step="0.05" value="0.2">
                <span class="slider-value">Radius: <span id="repulsion-radius-value">0.2</span></span>
            </div>
        </div>
    </div>

<script>
    function createShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
            return null;
        }
        return shader;
    }
    
    function initWebGL() {
    const canvas = document.getElementById('glcanvas');
    // CRITICAL FOR RENDERING – WebGL context setup
    const gl = canvas.getContext('webgl', { alpha: true });
    if (!gl) {
        alert('Unable to initialize WebGL. Your browser may not support it.');
        return;
    }

    // CRITICAL FOR RENDERING – Clear color and blending setup
    gl.clearColor(0.0, 0.0, 0.0, 0.0); // Fully transparent background
    gl.viewport(0, 0, canvas.width, canvas.height);
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

    
        // CRITICAL FOR RENDERING – Vertex shader (don't modify)
        const vertexShaderSource = `
            attribute vec2 position;
            void main() {
                gl_Position = vec4(position, 0.0, 1.0);
            }
        `;
    
        // CRITICAL FOR RENDERING – Fragment shader (don't modify)
        const fragmentShaderSource = `
        precision highp float;
        uniform float canvasWidth;
        uniform float canvasHeight;
        uniform float time;
        uniform vec2 metaballPositions[3];
        uniform vec2 mousePos;
        uniform float mouseForceEnabled;
        uniform float mouseForceStrength;
        uniform float mouseForceRadius;
        uniform float mouseForceType;
        uniform vec3 baseColor;
        uniform vec3 secondaryColor;
        uniform vec3 backgroundColor;
        uniform float velocityColorEnabled;
        uniform float velocityColorIntensity;
        uniform float distanceColorEnabled;
        uniform float distanceColorIntensity;

        float metaball(vec2 point, vec2 center, float radius) {
            vec2 aspectRatio = vec2(canvasWidth / canvasHeight, 1.0);
            point.x *= aspectRatio.x;
            center.x *= aspectRatio.x;
            float dx = point.x - center.x;
            float dy = point.y - center.y;
            return radius / (dx * dx + dy * dy);
        }

        void main() {
            vec2 point = gl_FragCoord.xy / vec2(canvasWidth, canvasHeight);
            float sum = 0.0;
            vec3 finalColor = vec3(1.0);

            // Calculate metaball field and colors
            for (int i = 0; i < 3; i++) {
                float fieldStrength = metaball(point, metaballPositions[i], 0.003125);
                sum += fieldStrength;

                // Calculate colors
                vec3 velocityBasedColor = velocityColorEnabled > 0.0 ? baseColor : baseColor;
                vec3 distanceBasedColor = distanceColorEnabled > 0.0 ? 
                    mix(baseColor, secondaryColor, smoothstep(0.0, distanceColorIntensity, fieldStrength)) : 
                    baseColor;
                
                float blendFactor = fieldStrength / (sum + 0.001);
                finalColor = mix(finalColor, mix(velocityBasedColor, distanceBasedColor, 0.5), blendFactor);
            }

            float edge0 = 0.25;
            float edge1 = 0.27;
            float alpha = smoothstep(edge0, edge1, sum);
            gl_FragColor = vec4(finalColor, alpha);
        }
        `;

    
        // CRITICAL FOR RENDERING – Shader compilation and linking
        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
    
        // CRITICAL FOR RENDERING – Program creation and linking
        const shaderProgram = gl.createProgram();
        
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        
        gl.linkProgram(shaderProgram);
        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
            return;
        }
        gl.useProgram(shaderProgram);
    
        // CRITICAL FOR RENDERING – Vertex buffer setup
        const vertices = new Float32Array([
            -1.0, -1.0, 1.0, -1.0, -1.0, 1.0,
            -1.0, 1.0, 1.0, -1.0, 1.0, 1.0,
        ]);
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
    
        const positionLocation = gl.getAttribLocation(shaderProgram, 'position');
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
    
        // CRITICAL FOR RENDERING – Uniform locations
        const canvasWidthLocation = gl.getUniformLocation(shaderProgram, 'canvasWidth');
        const canvasHeightLocation = gl.getUniformLocation(shaderProgram, 'canvasHeight');
        gl.uniform1f(canvasWidthLocation, canvas.width);
        gl.uniform1f(canvasHeightLocation, canvas.height);
    
        const timeLocation = gl.getUniformLocation(shaderProgram, 'time');
        let startTime = Date.now();
        let lastTime = startTime;

        // Control uniform locations
        const uniformLocations = {
            viscousDampingEnabled: gl.getUniformLocation(shaderProgram, 'VISCOUS_DAMPING_ENABLED'),
            viscosityFactor: gl.getUniformLocation(shaderProgram, 'viscosityFactor'),
            vorticityEnabled: gl.getUniformLocation(shaderProgram, 'VORTICITY_ENABLED'),
            vorticityFactor: gl.getUniformLocation(shaderProgram, 'vorticityFactor'),
            turbulenceEnabled: gl.getUniformLocation(shaderProgram, 'TURBULENCE_ENABLED'),
            turbulenceFactor: gl.getUniformLocation(shaderProgram, 'turbulenceFactor'),
            angularMomentumEnabled: gl.getUniformLocation(shaderProgram, 'ANGULAR_MOMENTUM_ENABLED'),
            angularMomentumFactor: gl.getUniformLocation(shaderProgram, 'angularMomentumFactor'),
            surfaceTensionEnabled: gl.getUniformLocation(shaderProgram, 'SURFACE_TENSION_ENABLED'),
            surfaceTensionFactor: gl.getUniformLocation(shaderProgram, 'surfaceTensionFactor'),
            gravityEnabled: gl.getUniformLocation(shaderProgram, 'GRAVITY_ENABLED'),
            gravityStrength: gl.getUniformLocation(shaderProgram, 'gravityStrength'),
            repulsionEnabled: gl.getUniformLocation(shaderProgram, 'REPULSION_ENABLED'),
            repulsionStrength: gl.getUniformLocation(shaderProgram, 'repulsionStrength'),
            repulsionRadius: gl.getUniformLocation(shaderProgram, 'repulsionRadius')
        };

        // Add color uniform locations
        const colorUniforms = {
            baseColor: gl.getUniformLocation(shaderProgram, 'baseColor'),
            secondaryColor: gl.getUniformLocation(shaderProgram, 'secondaryColor'),
            backgroundColor: gl.getUniformLocation(shaderProgram, 'backgroundColor'),
            velocityColorEnabled: gl.getUniformLocation(shaderProgram, 'velocityColorEnabled'),
            velocityColorIntensity: gl.getUniformLocation(shaderProgram, 'velocityColorIntensity'),
            distanceColorEnabled: gl.getUniformLocation(shaderProgram, 'distanceColorEnabled'),
            distanceColorIntensity: gl.getUniformLocation(shaderProgram, 'distanceColorIntensity')
        };

        // Initialize color uniforms
        gl.uniform3fv(colorUniforms.baseColor, hexToRGB('#FFFFFF')); // White base color
        gl.uniform3fv(colorUniforms.secondaryColor, hexToRGB('#88CCFF')); // Light blue secondary color
        gl.uniform3fv(colorUniforms.backgroundColor, hexToRGB('#207DCA')); // Background color
        gl.uniform1f(colorUniforms.velocityColorEnabled, 0.0);
        gl.uniform1f(colorUniforms.velocityColorIntensity, 1.0);
        gl.uniform1f(colorUniforms.distanceColorEnabled, 0.0);
        gl.uniform1f(colorUniforms.distanceColorIntensity, 1.0);

        // Initialize toggle states and uniforms
        gl.uniform1f(uniformLocations.viscousDampingEnabled, 0.0);
        gl.uniform1f(uniformLocations.vorticityEnabled, 0.0);
        gl.uniform1f(uniformLocations.turbulenceEnabled, 0.0);
        gl.uniform1f(uniformLocations.angularMomentumEnabled, 0.0);
        gl.uniform1f(uniformLocations.surfaceTensionEnabled, 0.0);
        gl.uniform1f(uniformLocations.gravityEnabled, 1.0);  // Start enabled
        gl.uniform1f(uniformLocations.repulsionEnabled, 1.0);  // Start enabled

        // Initialize surface tension controls
        gl.uniform1f(uniformLocations.surfaceTensionEnabled, 0.0);
        gl.uniform1f(uniformLocations.surfaceTensionFactor, 0.03);

        document.getElementById('surface-tension-toggle').addEventListener('change', function(e) {
            gl.uniform1f(uniformLocations.surfaceTensionEnabled, e.target.checked ? 1.0 : 0.0);
        });

        document.getElementById('surface-tension-slider').addEventListener('input', function(e) {
            const value = parseFloat(e.target.value);
            gl.uniform1f(uniformLocations.surfaceTensionFactor, value);
            document.getElementById('surface-tension-value').textContent = value.toFixed(5);
        });

        // Initialize surface tension value display
        document.getElementById('surface-tension-value').textContent = 
            parseFloat(document.getElementById('surface-tension-slider').value).toFixed(5);

        // Initialize viscous damping controls
        document.getElementById('viscous-damping-toggle').addEventListener('change', function(e) {
            const isEnabled = e.target.checked;
            gl.uniform1f(uniformLocations.viscousDampingEnabled, isEnabled ? 1.0 : 0.0);
        });

        document.getElementById('viscous-damping-slider').addEventListener('input', function(e) {
            const value = parseFloat(e.target.value);
            gl.uniform1f(uniformLocations.viscosityFactor, value);
            document.getElementById('viscous-damping-value').textContent = value.toFixed(5);
        });

        // Initialize viscous damping value display
        document.getElementById('viscous-damping-value').textContent = 
            parseFloat(document.getElementById('viscous-damping-slider').value).toFixed(5);

        // Add toggle event listeners
        document.getElementById('vorticity-toggle').addEventListener('change', function(e) {
            gl.uniform1f(uniformLocations.vorticityEnabled, e.target.checked ? 1.0 : 0.0);
        });

        document.getElementById('turbulence-toggle').addEventListener('change', function(e) {
            gl.uniform1f(uniformLocations.turbulenceEnabled, e.target.checked ? 1.0 : 0.0);
        });

        document.getElementById('angular-momentum-toggle').addEventListener('change', function(e) {
            gl.uniform1f(uniformLocations.angularMomentumEnabled, e.target.checked ? 1.0 : 0.0);
        });

        // Add repulsion controls
        document.getElementById('repulsion-toggle').addEventListener('change', function(e) {
            gl.uniform1f(uniformLocations.repulsionEnabled, e.target.checked ? 1.0 : 0.0);
        });

        document.getElementById('repulsion-slider').addEventListener('input', function(e) {
            const value = parseFloat(e.target.value);
            gl.uniform1f(uniformLocations.repulsionStrength, value);
            document.getElementById('repulsion-value').textContent = value.toFixed(5);
        });

        document.getElementById('repulsion-radius-slider').addEventListener('input', function(e) {
            const value = parseFloat(e.target.value);
            gl.uniform1f(uniformLocations.repulsionRadius, value);
            document.getElementById('repulsion-radius-value').textContent = value.toFixed(5);
        });

        // Add gravity controls
        document.getElementById('gravity-toggle').addEventListener('change', function(e) {
            gl.uniform1f(uniformLocations.gravityEnabled, e.target.checked ? 1.0 : 0.0);
        });

        document.getElementById('gravity-slider').addEventListener('input', function(e) {
            const value = parseFloat(e.target.value);
            gl.uniform1f(uniformLocations.gravityStrength, value);
            document.getElementById('gravity-value').textContent = value.toFixed(5);
        });

        // Initialize gravity uniform
        gl.uniform1f(uniformLocations.gravityStrength, 0.002);

        // Add color control event listeners
        document.getElementById('base-color').addEventListener('input', function(e) {
            gl.uniform3fv(colorUniforms.baseColor, hexToRGB(e.target.value));
        });

        document.getElementById('secondary-color').addEventListener('input', function(e) {
            gl.uniform3fv(colorUniforms.secondaryColor, hexToRGB(e.target.value));
        });

        document.getElementById('background-color').addEventListener('input', function(e) {
            gl.uniform3fv(colorUniforms.backgroundColor, hexToRGB(e.target.value));
            document.getElementById('glcanvas').style.backgroundColor = e.target.value;
        });

        document.getElementById('velocity-color-toggle').addEventListener('change', function(e) {
            gl.uniform1f(colorUniforms.velocityColorEnabled, e.target.checked ? 1.0 : 0.0);
        });

        document.getElementById('velocity-color-slider').addEventListener('input', function(e) {
            const value = parseFloat(e.target.value);
            gl.uniform1f(colorUniforms.velocityColorIntensity, value);
            document.getElementById('velocity-color-value').textContent = value.toFixed(5);
        });

        document.getElementById('distance-color-toggle').addEventListener('change', function(e) {
            gl.uniform1f(colorUniforms.distanceColorEnabled, e.target.checked ? 1.0 : 0.0);
        });

        document.getElementById('distance-color-slider').addEventListener('input', function(e) {
            const value = parseFloat(e.target.value);
            gl.uniform1f(colorUniforms.distanceColorIntensity, value);
            document.getElementById('distance-color-value').textContent = value.toFixed(5);
        });

        // Add mouse tracking
        let mouseX = 0;
        let mouseY = 0;
        let isAttracting = true;

        // Update mouse tracking to use canvas coordinates properly
        function updateMousePosition(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            mouseX = ((e.clientX - rect.left) * scaleX) / canvas.width;
            mouseY = 1.0 - ((e.clientY - rect.top) * scaleY) / canvas.height;
            
            gl.uniform2f(gl.getUniformLocation(shaderProgram, 'mousePos'), mouseX, mouseY);
        }

        canvas.addEventListener('mousemove', updateMousePosition);
        canvas.addEventListener('mouseenter', updateMousePosition);

        // Update mouse controls setup
        function setupMouseControls() {
            const attractButton = document.getElementById('attract-button');
            const repelButton = document.getElementById('repel-button');

            document.getElementById('mouse-force-toggle').addEventListener('change', function(e) {
                gl.uniform1f(gl.getUniformLocation(shaderProgram, 'mouseForceEnabled'), e.target.checked ? 1.0 : 0.0);
            });

            document.getElementById('mouse-force-slider').addEventListener('input', function(e) {
                const value = parseFloat(e.target.value);
                gl.uniform1f(gl.getUniformLocation(shaderProgram, 'mouseForceStrength'), value);
                document.getElementById('mouse-force-value').textContent = value.toFixed(5);
            });

            document.getElementById('mouse-radius-slider').addEventListener('input', function(e) {
                const value = parseFloat(e.target.value);
                gl.uniform1f(gl.getUniformLocation(shaderProgram, 'mouseForceRadius'), value);
                document.getElementById('mouse-radius-value').textContent = value;
            });

            attractButton.addEventListener('click', function() {
                isAttracting = true;
                gl.uniform1f(gl.getUniformLocation(shaderProgram, 'mouseForceType'), 1.0);
                attractButton.classList.add('active');
                repelButton.classList.remove('active');
            });

            repelButton.addEventListener('click', function() {
                isAttracting = false;
                gl.uniform1f(gl.getUniformLocation(shaderProgram, 'mouseForceType'), -1.0);
                repelButton.classList.add('active');
                attractButton.classList.remove('active');
            });
        }

        // Maximum number of metaballs we'll support
        const maxMetaballs = 3;
        
        // Store metaball state
        let metaballState = {
            positions: [],
            velocities: [],
            lastPositions: [] // For calculating velocity
        };

        // Initialize metaball positions in a circle
        function initializeMetaballs() {
            const radius = 0.4;
            const angleStep = (Math.PI * 2) / maxMetaballs;
            
            for (let i = 0; i < maxMetaballs; i++) {
                const angle = -Math.PI/2 + (i * angleStep);
                const x = Math.cos(angle) * radius + 0.5;
                const y = Math.sin(angle) * radius + 0.5;
                
                metaballState.positions.push(x, y);
                metaballState.velocities.push(0, 0);
                metaballState.lastPositions.push(x, y);
            }
        }

        function updatePhysics(deltaTime) {
            for (let i = 0; i < maxMetaballs; i++) {
                const idx = i * 2;
                let x = metaballState.positions[idx];
                let y = metaballState.positions[idx + 1];
                let vx = metaballState.velocities[idx];
                let vy = metaballState.velocities[idx + 1];

                // Store last position
                metaballState.lastPositions[idx] = x;
                metaballState.lastPositions[idx + 1] = y;

                // Apply viscous damping
                if (document.getElementById('viscous-damping-toggle').checked) {
                    const viscosity = parseFloat(document.getElementById('viscous-damping-slider').value);
                    vx *= viscosity;
                    vy *= viscosity;
                }

                // Apply vorticity
                if (document.getElementById('vorticity-toggle').checked) {
                    const vorticity = parseFloat(document.getElementById('vorticity-slider').value);
                    const toCenter = [0.5 - x, 0.5 - y];
                    const dist = Math.sqrt(toCenter[0] * toCenter[0] + toCenter[1] * toCenter[1]);
                    if (dist > 0.001) {
                        // Create perpendicular force for rotation
                        const perpForce = [-toCenter[1], toCenter[0]];
                        vx += (perpForce[0] / dist) * vorticity * deltaTime;
                        vy += (perpForce[1] / dist) * vorticity * deltaTime;
                    }
                }

                // Apply turbulence
                if (document.getElementById('turbulence-toggle').checked) {
                    const turbulence = parseFloat(document.getElementById('turbulence-slider').value);
                    const time = Date.now() / 1000;
                    vx += Math.sin(time * 5 + y * 10) * turbulence * deltaTime;
                    vy += Math.cos(time * 5 + x * 10) * turbulence * deltaTime;
                }

                // Apply angular momentum
                if (document.getElementById('angular-momentum-toggle').checked) {
                    const angularMomentum = parseFloat(document.getElementById('angular-momentum-slider').value);
                    const toCenter = [0.5 - x, 0.5 - y];
                    const dist = Math.sqrt(toCenter[0] * toCenter[0] + toCenter[1] * toCenter[1]);
                    
                    if (dist > 0.001) {
                        // Calculate perpendicular direction for orbital motion
                        const perpForce = [-toCenter[1] / dist, toCenter[0] / dist];
                        
                        // Apply force perpendicular to radius, scaled by distance
                        // This creates proper orbital motion with distance-dependent strength
                        const forceMagnitude = angularMomentum / Math.sqrt(dist);
                        vx += perpForce[0] * forceMagnitude;
                        vy += perpForce[1] * forceMagnitude;
                    }
                }

                // Apply surface tension
                if (document.getElementById('surface-tension-toggle').checked) {
                    const surfaceTension = parseFloat(document.getElementById('surface-tension-slider').value);
                    for (let j = 0; j < maxMetaballs; j++) {
                        if (i === j) continue;
                        const dx = x - metaballState.positions[j * 2];
                        const dy = y - metaballState.positions[j * 2 + 1];
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        // Optimal distance for metaballs
                        const optimalDist = 0.3;
                        
                        if (dist > 0.001) {  // Avoid division by zero
                            // Create attractive force when metaballs are too far apart
                            // and repulsive force when they're too close
                            const force = surfaceTension * (dist - optimalDist);
                            vx -= (dx / dist) * force;
                            vy -= (dy / dist) * force;
                        }
                    }
                }

                // Apply gravity
                if (document.getElementById('gravity-toggle').checked) {
                    const toCenter = [0.5 - x, 0.5 - y];
                    const dist = Math.sqrt(toCenter[0] * toCenter[0] + toCenter[1] * toCenter[1]);
                    const gravityStrength = parseFloat(document.getElementById('gravity-slider').value);
                    
                    if (dist > 0.001) {
                        const force = gravityStrength;
                        vx += (toCenter[0] / dist) * force;
                        vy += (toCenter[1] / dist) * force;
                    }
                }

                // Apply repulsion
                if (document.getElementById('repulsion-toggle').checked) {
                    const repulsionStrength = parseFloat(document.getElementById('repulsion-slider').value);
                    const repulsionRadius = parseFloat(document.getElementById('repulsion-radius-slider').value);

                    for (let j = 0; j < maxMetaballs; j++) {
                        if (i === j) continue;
                        
                        const dx = x - metaballState.positions[j * 2];
                        const dy = y - metaballState.positions[j * 2 + 1];
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < repulsionRadius && dist > 0.001) {
                            const force = repulsionStrength * (1.0 - dist / repulsionRadius);
                            vx += (dx / dist) * force;
                            vy += (dy / dist) * force;
                        }
                    }
                }

                // Apply damping (base damping always active)
                const baseDamping = document.getElementById('viscous-damping-toggle').checked ? 1.0 : 0.99;
                vx *= baseDamping;
                vy *= baseDamping;

                // Update position
                x += vx;
                y += vy;

                // Bounce off walls
                if (x < 0) { x = 0; vx *= -0.8; }
                if (x > 1) { x = 1; vx *= -0.8; }
                if (y < 0) { y = 0; vy *= -0.8; }
                if (y > 1) { y = 1; vy *= -0.8; }

                // Store updated state
                metaballState.positions[idx] = x;
                metaballState.positions[idx + 1] = y;
                metaballState.velocities[idx] = vx;
                metaballState.velocities[idx + 1] = vy;
            }
        }

        function updateMetaballPositions(currentTime) {
            // First frame initialization
            if (metaballState.positions.length === 0) {
                initializeMetaballs();
            }

            // Calculate deltaTime
            const deltaTime = (currentTime - lastTime) / 1000.0;
            lastTime = currentTime;

            // Update physics
            updatePhysics(deltaTime);

            // Update shader uniforms
            for (let i = 0; i < maxMetaballs; i++) {
                const posLocation = gl.getUniformLocation(shaderProgram, `metaballPositions[${i}]`);
                gl.uniform2f(posLocation, metaballState.positions[i*2], metaballState.positions[i*2+1]);
            }
        }

        function animate() {
            const currentTime = Date.now();
            const deltaTime = (currentTime - lastTime) / 1000.0;
            lastTime = currentTime;

            gl.uniform1f(timeLocation, (currentTime - startTime) / 1000.0 * 2);
            
            updateMetaballPositions(currentTime);
            draw();
            requestAnimationFrame(animate);
        }
    
        // CRITICAL FOR RENDERING – Draw function
        function draw() {
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.drawArrays(gl.TRIANGLES, 0, 6);
        }
    
        animate();
    }
    
    window.onload = initWebGL;

    // Helper function to convert hex to RGB
    function hexToRGB(hex) {
        const r = parseInt(hex.slice(1, 3), 16) / 255;
        const g = parseInt(hex.slice(3, 5), 16) / 255;
        const b = parseInt(hex.slice(5, 7), 16) / 255;
        return [r, g, b];
    }

    // Initialize all uniform values and add event listeners
    gl.uniform1f(uniformLocations.viscosityFactor, 0.9);
    gl.uniform1f(uniformLocations.vorticityFactor, 0.9);
    gl.uniform1f(uniformLocations.turbulenceFactor, 0.5);
    gl.uniform1f(uniformLocations.angularMomentumFactor, 0.003);
    gl.uniform1f(uniformLocations.surfaceTensionFactor, 0.03);

    // Add all slider event listeners
    document.getElementById('viscous-damping-slider').addEventListener('input', function(e) {
        const value = parseFloat(e.target.value);
        gl.uniform1f(uniformLocations.viscosityFactor, value);
        document.getElementById('viscous-damping-value').textContent = value.toFixed(5);
    });

    // Initialize viscous damping value display
    document.getElementById('viscous-damping-value').textContent = 
        parseFloat(document.getElementById('viscous-damping-slider').value).toFixed(5);

    document.getElementById('vorticity-slider').addEventListener('input', function(e) {
        const value = parseFloat(e.target.value);
        gl.uniform1f(uniformLocations.vorticityFactor, value);
        document.getElementById('vorticity-value').textContent = value.toFixed(5);
    });

    document.getElementById('turbulence-slider').addEventListener('input', function(e) {
        const value = parseFloat(e.target.value);
        gl.uniform1f(uniformLocations.turbulenceFactor, value);
        document.getElementById('turbulence-value').textContent = value.toFixed(5);
    });

    document.getElementById('angular-momentum-slider').addEventListener('input', function(e) {
        const value = parseFloat(e.target.value);
        gl.uniform1f(uniformLocations.angularMomentumFactor, value);
        document.getElementById('angular-momentum-value').textContent = value.toFixed(5);
    });

    document.getElementById('surface-tension-slider').addEventListener('input', function(e) {
        const value = parseFloat(e.target.value);
        gl.uniform1f(uniformLocations.surfaceTensionFactor, value);
        document.getElementById('surface-tension-value').textContent = value.toFixed(5);
    });

    document.getElementById('gravity-slider').addEventListener('input', function(e) {
        const value = parseFloat(e.target.value);
        gl.uniform1f(uniformLocations.gravityStrength, value);
        document.getElementById('gravity-value').textContent = value.toFixed(5);
    });

    document.getElementById('repulsion-slider').addEventListener('input', function(e) {
        const value = parseFloat(e.target.value);
        gl.uniform1f(uniformLocations.repulsionStrength, value);
        document.getElementById('repulsion-value').textContent = value.toFixed(5);
    });

    document.getElementById('repulsion-radius-slider').addEventListener('input', function(e) {
        const value = parseFloat(e.target.value);
        gl.uniform1f(uniformLocations.repulsionRadius, value);
        document.getElementById('repulsion-radius-value').textContent = value.toFixed(5);
    });

    document.getElementById('mouse-force-slider').addEventListener('input', function(e) {
        const value = parseFloat(e.target.value);
        gl.uniform1f(gl.getUniformLocation(shaderProgram, 'mouseForceStrength'), value);
        document.getElementById('mouse-force-value').textContent = value.toFixed(5);
    });

    document.getElementById('velocity-color-slider').addEventListener('input', function(e) {
        const value = parseFloat(e.target.value);
        gl.uniform1f(colorUniforms.velocityColorIntensity, value);
        document.getElementById('velocity-color-value').textContent = value.toFixed(5);
    });

    document.getElementById('distance-color-slider').addEventListener('input', function(e) {
        const value = parseFloat(e.target.value);
        gl.uniform1f(colorUniforms.distanceColorIntensity, value);
        document.getElementById('distance-color-value').textContent = value.toFixed(5);
    });
</script>
    
</body>
</html>


