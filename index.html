<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Metaballs in WebGL - Full Example</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        canvas {
            width: 800px; /* Changed from 100vw */
            height: 800px; /* Changed from 100vh */
            display: block;
            background-color:#207DCA;
        }
    </style>
</head>
<body>
<canvas id="glcanvas" width="500" height="500"></canvas> <!-- Set explicit dimensions -->
<script>
    function createShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
            return null;
        }
        return shader;
    }
    
    function initWebGL() {
    const canvas = document.getElementById('glcanvas');
    // CRITICAL FOR RENDERING – WebGL context setup
    const gl = canvas.getContext('webgl', { alpha: true });
    if (!gl) {
        alert('Unable to initialize WebGL. Your browser may not support it.');
        return;
    }

    // CRITICAL FOR RENDERING – Clear color and blending setup
    gl.clearColor(0.0, 0.0, 0.0, 0.0); // Fully transparent background
    gl.viewport(0, 0, canvas.width, canvas.height);
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

    
        // CRITICAL FOR RENDERING – Vertex shader (don't modify)
        const vertexShaderSource = `
            attribute vec2 position;
            void main() {
                gl_Position = vec4(position, 0.0, 1.0);
            }
        `;
    
        // CRITICAL FOR RENDERING – Fragment shader (don't modify)
        const fragmentShaderSource = `
        precision highp float;
        uniform float canvasWidth;
        uniform float canvasHeight;
        uniform float time;
        uniform vec2 metaballPositions[3];

        // EFFECT CONTROLS
        // ----------------------------
        const float DAMPING_ENABLED = 1.0;  // 1.0 = on, 0.0 = off
        float dampingFactor = 0.90;         // Increased damping (was 0.95)
                                           // Lower value = stronger damping
                                           // Try values: 0.95 (subtle), 0.80 (medium), 0.60 (strong)

        const float VORTICITY_ENABLED = 1.0;  // 1.0 = on, 0.0 = off
        float vorticityFactor = 0.9;         // Controls strength of the vortex effect
                                            // Try values: 0.2 (subtle), 0.5 (medium), 1.0 (strong)

        float metaball(vec2 point, vec2 center, float radius) {
            vec2 aspectRatio = vec2(canvasWidth / canvasHeight, 1.0);
            point.x *= aspectRatio.x;
            center.x *= aspectRatio.x;
            float dx = point.x - center.x;
            float dy = point.y - center.y;
            return radius / (dx * dx + dy * dy);
        }

        vec2 applyVortex(vec2 position, vec2 center, float t) {
            vec2 toCenter = center - position;
            float dist = length(toCenter);
            
            // Normalize distance to control the effect strength
            float normalizedDist = clamp(dist, 0.0, 1.0);
            
            // Make the rotation slower and more controlled
            // Rotation is faster when closer to center, but capped
            float angle = t * vorticityFactor * 0.2 * (1.0 - normalizedDist * 0.8);
            
            // Rotate the position around the center
            float s = sin(angle);
            float c = cos(angle);
            vec2 rotated = vec2(
                toCenter.x * c - toCenter.y * s,
                toCenter.x * s + toCenter.y * c
            );
            
            // Add a small inward pull to maintain the spiral
            float pullStrength = 0.02 * vorticityFactor;
            rotated = rotated * (1.0 - pullStrength);
            
            // Ensure the position stays within bounds
            vec2 newPos = center - rotated;
            return clamp(newPos, vec2(0.0), vec2(1.0));
        }

        void main() {
            vec2 point = gl_FragCoord.xy / vec2(canvasWidth, canvasHeight);
            float sum = 0.0;
            vec2 canvasCenter = vec2(0.5, 0.5);

            for (int i = 0; i < 3; i++) {
                float delay = 0.15 * float(i);
                float lerpFactor = (sin(time - delay) + 1.0) / 2.0;
                
                // Apply damping to movement
                lerpFactor *= mix(1.0, dampingFactor, DAMPING_ENABLED);
                
                vec2 position = metaballPositions[i];
                
                // Apply vortex effect to the movement
                if (VORTICITY_ENABLED > 0.0) {
                    position = applyVortex(position, canvasCenter, time);
                }
                
                // Mix with center position
                position = mix(position, canvasCenter, lerpFactor * 0.95);
                
                sum += metaball(point, position, 0.003125);
            }

            float edge0 = 0.25;
            float edge1 = 0.27;
            float alpha = smoothstep(edge0, edge1, sum);
            gl_FragColor = vec4(1.0, 1.0, 1.0, alpha);
        }
        `;

    
        // CRITICAL FOR RENDERING – Shader compilation and linking
        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
    
        // CRITICAL FOR RENDERING – Program creation and linking
        const shaderProgram = gl.createProgram();
        
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        
        gl.linkProgram(shaderProgram);
        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
            return;
        }
        gl.useProgram(shaderProgram);
    
        // CRITICAL FOR RENDERING – Vertex buffer setup
        const vertices = new Float32Array([
            -1.0, -1.0, 1.0, -1.0, -1.0, 1.0,
            -1.0, 1.0, 1.0, -1.0, 1.0, 1.0,
        ]);
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
    
        const positionLocation = gl.getAttribLocation(shaderProgram, 'position');
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
    
        // CRITICAL FOR RENDERING – Uniform locations
        const canvasWidthLocation = gl.getUniformLocation(shaderProgram, 'canvasWidth');
        const canvasHeightLocation = gl.getUniformLocation(shaderProgram, 'canvasHeight');
        gl.uniform1f(canvasWidthLocation, canvas.width);
        gl.uniform1f(canvasHeightLocation, canvas.height);
    
        const timeLocation = gl.getUniformLocation(shaderProgram, 'time');
        let startTime = Date.now();

        // Maximum number of metaballs we'll support
        const maxMetaballs = 3; // Changed from 9 to 3

        // ✅ SAFE TO MODIFY – Calculate and update metaball positions in JavaScript
        function updateMetaballPositions(currentTime) {
            const metaballPositions = [];
            
            // SPREAD CONTROL
            // -------------
            // radius: Controls how far apart the metaballs are in their circular arrangement
            // Current value: 0.75 for large spread
            // - Decrease to keep metaballs closer together (try 0.4)
            // - Increase to spread them further apart
            // Note: This works with the field strength in the shader (0.003125)
            // If you change one, you might need to adjust the other
            const radius = 0.4; // Reduced from 0.75 to keep balls closer together

            for (let i = 0; i < maxMetaballs; i++) {
                const angle = (i / maxMetaballs) * Math.PI * 2;
                metaballPositions.push(Math.cos(angle) * radius + 0.5);
                metaballPositions.push(Math.sin(angle) * radius + 0.5);
            }
            return metaballPositions;
        }
    
        // ✅ SAFE TO MODIFY – Animation loop (this is where you control movement)
        function animate() {
            let currentTime = ((Date.now() - startTime) / 1000.0) * 2; // Speed factor of 2

            gl.uniform1f(timeLocation, currentTime);
            
            const metaballPositions = updateMetaballPositions(currentTime);
            // CRITICAL FOR RENDERING – Pass positions to shader
            for (let i = 0; i < maxMetaballs; i++) {
                const uniformLocation = gl.getUniformLocation(shaderProgram, `metaballPositions[${i}]`);
                gl.uniform2fv(uniformLocation, metaballPositions.slice(i * 2, i * 2 + 2));
            }
            
            draw();
            requestAnimationFrame(animate);
        }
    
        // CRITICAL FOR RENDERING – Draw function
        function draw() {
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.drawArrays(gl.TRIANGLES, 0, 6);
        }
    
        animate();
    }
    
    window.onload = initWebGL;
    </script>
    
</body>
</html>


