<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Metaballs in WebGL - Full Example</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        canvas {
            width: 800px; /* Changed from 100vw */
            height: 800px; /* Changed from 100vh */
            display: block;
            background-color:#207DCA;
        }
    </style>
</head>
<body>
<canvas id="glcanvas" width="500" height="500"></canvas> <!-- Set explicit dimensions -->
<script>
    function createShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
            return null;
        }
        return shader;
    }
    
    function initWebGL() {
    const canvas = document.getElementById('glcanvas');
    // CRITICAL FOR RENDERING – WebGL context setup
    const gl = canvas.getContext('webgl', { alpha: true });
    if (!gl) {
        alert('Unable to initialize WebGL. Your browser may not support it.');
        return;
    }

    // CRITICAL FOR RENDERING – Clear color and blending setup
    gl.clearColor(0.0, 0.0, 0.0, 0.0); // Fully transparent background
    gl.viewport(0, 0, canvas.width, canvas.height);
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

    
        // CRITICAL FOR RENDERING – Vertex shader (don't modify)
        const vertexShaderSource = `
            attribute vec2 position;
            void main() {
                gl_Position = vec4(position, 0.0, 1.0);
            }
        `;
    
        // CRITICAL FOR RENDERING – Fragment shader (don't modify)
        const fragmentShaderSource = `
        precision highp float;
        uniform float canvasWidth;
        uniform float canvasHeight;
        uniform float time;
        uniform vec2 metaballPositions[3];

        // MOVEMENT CONTROLS
        // ----------------
        // movementScale: Controls how far balls move towards/away from center
        // - 0.95 = full movement range
        // - 0.5 = half movement range
        // - 0.25 = quarter movement range
        float movementScale = 0.95;

        // METABALL FIELD CONTROLS
        // ----------------------
        // Field radius affects the size and interaction of metaballs
        // Larger radius = earlier/more blending between balls
        // Current value: 0.003125 for large distinct balls
        // Try: 0.006 for earlier blending
        float metaball(vec2 point, vec2 center, float radius) {
            vec2 aspectRatio = vec2(canvasWidth / canvasHeight, 1.0);
            point.x *= aspectRatio.x;
            center.x *= aspectRatio.x;
            float dx = point.x - center.x;
            float dy = point.y - center.y;
            return radius / (dx * dx + dy * dy);
        }

        void main() {
            vec2 point = gl_FragCoord.xy / vec2(canvasWidth, canvasHeight);
            float sum = 0.0;
            vec2 canvasCenter = vec2(0.5, 0.5);

            for (int i = 0; i < 3; i++) {
                float delay = 0.15 * float(i);
                float lerpFactor = (sin(time - delay) + 1.0) / 2.0;
                vec2 targetPosition = mix(metaballPositions[i], canvasCenter, lerpFactor * movementScale);
                sum += metaball(point, targetPosition, 0.003125);  // Keep original field strength
            }

            // VISCOSITY & EDGE CONTROL
            // -----------------------
            // edge0 = 0.25: Start blending early (more liquid-like)
            // edge1 - edge0 = 0.02: Sharp edges (was 0.04)
            // 
            // For even sharper edges: reduce difference to 0.01
            // For softer edges: increase difference up to 0.04
            float edge0 = 0.25;  // Keep early blending
            float edge1 = 0.27;  // Reduced gap for sharper edges
            float alpha = smoothstep(edge0, edge1, sum);
            gl_FragColor = vec4(1, 1, 1, alpha);
        }
        `;

    
        // CRITICAL FOR RENDERING – Shader compilation and linking
        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
    
        // CRITICAL FOR RENDERING – Program creation and linking
        const shaderProgram = gl.createProgram();
        
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        
        gl.linkProgram(shaderProgram);
        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
            return;
        }
        gl.useProgram(shaderProgram);
    
        // CRITICAL FOR RENDERING – Vertex buffer setup
        const vertices = new Float32Array([
            -1.0, -1.0, 1.0, -1.0, -1.0, 1.0,
            -1.0, 1.0, 1.0, -1.0, 1.0, 1.0,
        ]);
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
    
        const positionLocation = gl.getAttribLocation(shaderProgram, 'position');
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
    
        // CRITICAL FOR RENDERING – Uniform locations
        const canvasWidthLocation = gl.getUniformLocation(shaderProgram, 'canvasWidth');
        const canvasHeightLocation = gl.getUniformLocation(shaderProgram, 'canvasHeight');
        gl.uniform1f(canvasWidthLocation, canvas.width);
        gl.uniform1f(canvasHeightLocation, canvas.height);
    
        const timeLocation = gl.getUniformLocation(shaderProgram, 'time');
        let startTime = Date.now();

        // Maximum number of metaballs we'll support
        const maxMetaballs = 3; // Changed from 9 to 3

        // ✅ SAFE TO MODIFY – Calculate and update metaball positions in JavaScript
        function updateMetaballPositions(currentTime) {
            const metaballPositions = [];
            
            // SPREAD CONTROL
            // -------------
            // radius: Controls how far apart the metaballs are in their circular arrangement
            // Current value: 0.75 for large spread
            // - Decrease to keep metaballs closer together (try 0.4)
            // - Increase to spread them further apart
            // Note: This works with the field strength in the shader (0.003125)
            // If you change one, you might need to adjust the other
            const radius = 0.4; // Reduced from 0.75 to keep balls closer together

            for (let i = 0; i < maxMetaballs; i++) {
                const angle = (i / maxMetaballs) * Math.PI * 2;
                metaballPositions.push(Math.cos(angle) * radius + 0.5);
                metaballPositions.push(Math.sin(angle) * radius + 0.5);
            }
            return metaballPositions;
        }
    
        // ✅ SAFE TO MODIFY – Animation loop (this is where you control movement)
        function animate() {
            let currentTime = ((Date.now() - startTime) / 1000.0) * 2; // Speed factor of 2

            gl.uniform1f(timeLocation, currentTime);
            
            const metaballPositions = updateMetaballPositions(currentTime);
            // CRITICAL FOR RENDERING – Pass positions to shader
            for (let i = 0; i < maxMetaballs; i++) {
                const uniformLocation = gl.getUniformLocation(shaderProgram, `metaballPositions[${i}]`);
                gl.uniform2fv(uniformLocation, metaballPositions.slice(i * 2, i * 2 + 2));
            }
            
            draw();
            requestAnimationFrame(animate);
        }
    
        // CRITICAL FOR RENDERING – Draw function
        function draw() {
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.drawArrays(gl.TRIANGLES, 0, 6);
        }
    
        animate();
    }
    
    window.onload = initWebGL;
    </script>
    
</body>
</html>
