<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Metaballs in WebGL - Full Example</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        }
        
        canvas {
            width: 800px;
            height: 800px;
            display: block;
            background-color:#207DCA;
        }

        #controls-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            color: white;
            width: 300px;
            max-height: 90vh;
            overflow-y: auto;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }

        .control-group {
            margin-bottom: 20px;
            padding: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 5px;
        }

        .control-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .toggle-slider {
            background-color: #2196F3;
        }

        input:checked + .toggle-slider:before {
            transform: translateX(26px);
        }

        .slider-container {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .range-slider {
            width: 100%;
            margin: 10px 0;
        }

        .slider-value {
            font-size: 0.8em;
            color: #aaa;
        }

        .color-picker-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
        }

        .color-picker {
            -webkit-appearance: none;
            width: 50px;
            height: 30px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        .color-picker::-webkit-color-swatch-wrapper {
            padding: 0;
        }

        .color-picker::-webkit-color-swatch {
            border: none;
            border-radius: 5px;
        }

        /* Add styles for the force type selector */
        .force-type-selector {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            gap: 10px;
        }

        .force-type-button {
            flex: 1;
            padding: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .force-type-button.active {
            background: #2196F3;
            border-color: #2196F3;
        }
    </style>
</head>
<body>
    <canvas id="glcanvas" width="500" height="500"></canvas>
    
    <div id="controls-panel">
        <h3 style="margin-top: 0;">Effect Controls</h3>
        
        <!-- Color Controls -->
        <div class="control-group">
            <h4 style="margin-top: 0;">Color Settings</h4>
            
            <!-- Base Color -->
            <div class="control-header">
                <span>Base Color</span>
                <div class="color-picker-container">
                    <input type="color" id="base-color" class="color-picker" value="#FFFFFF">
                </div>
            </div>

            <!-- Secondary Color -->
            <div class="control-header">
                <span>Secondary Color</span>
                <div class="color-picker-container">
                    <input type="color" id="secondary-color" class="color-picker" value="#88CCFF">
                </div>
            </div>

            <!-- Background Color -->
            <div class="control-header">
                <span>Background Color</span>
                <div class="color-picker-container">
                    <input type="color" id="background-color" class="color-picker" value="#207DCA">
                </div>
            </div>

            <!-- Velocity Color Effect -->
            <div class="control-header">
                <span>Velocity Color</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="velocity-color-toggle" checked>
                    <span class="toggle-slider"></span>
                </label>
            </div>
            <div class="slider-container">
                <input type="range" id="velocity-color-slider" class="range-slider" 
                       min="0.1" max="2.0" step="0.1" value="1.0">
                <span class="slider-value">Intensity: <span id="velocity-color-value">1.0</span></span>
            </div>

            <!-- Distance Color Effect -->
            <div class="control-header">
                <span>Distance Blend</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="distance-color-toggle" checked>
                    <span class="toggle-slider"></span>
                </label>
            </div>
            <div class="slider-container">
                <input type="range" id="distance-color-slider" class="range-slider" 
                       min="0.1" max="2.0" step="0.1" value="1.0">
                <span class="slider-value">Blend: <span id="distance-color-value">1.0</span></span>
            </div>
        </div>

        <!-- Mouse Interaction -->
        <div class="control-group">
            <h4 style="margin-top: 0;">Mouse Interaction</h4>
            
            <!-- Mouse Force Toggle -->
            <div class="control-header">
                <span>Mouse Force</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="mouse-force-toggle" checked>
                    <span class="toggle-slider"></span>
                </label>
            </div>

            <!-- Force Type Selector -->
            <div class="force-type-selector">
                <button id="attract-button" class="force-type-button active">Attract</button>
                <button id="repel-button" class="force-type-button">Repel</button>
            </div>

            <!-- Force Strength -->
            <div class="slider-container">
                <input type="range" id="mouse-force-slider" class="range-slider" 
                       min="0.1" max="2.0" step="0.1" value="1.0">
                <span class="slider-value">Force: <span id="mouse-force-value">1.0</span></span>
            </div>

            <!-- Effect Radius -->
            <div class="slider-container">
                <input type="range" id="mouse-radius-slider" class="range-slider" 
                       min="50" max="300" step="10" value="150">
                <span class="slider-value">Radius: <span id="mouse-radius-value">150</span>px</span>
            </div>
        </div>

        <!-- Viscous Damping -->
        <div class="control-group">
            <div class="control-header">
                <span>Viscous Damping</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="viscous-damping-toggle" checked>
                    <span class="toggle-slider"></span>
                </label>
            </div>
            <div class="slider-container">
                <input type="range" id="viscous-damping-slider" class="range-slider" 
                       min="0.8" max="0.99" step="0.01" value="0.9">
                <span class="slider-value">Strength: <span id="viscous-damping-value">0.9</span></span>
            </div>
        </div>

        <!-- Vorticity -->
        <div class="control-group">
            <div class="control-header">
                <span>Vorticity</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="vorticity-toggle">
                    <span class="toggle-slider"></span>
                </label>
            </div>
            <div class="slider-container">
                <input type="range" id="vorticity-slider" class="range-slider" 
                       min="0.1" max="2.0" step="0.1" value="0.9">
                <span class="slider-value">Strength: <span id="vorticity-value">0.9</span></span>
            </div>
        </div>

        <!-- Turbulence -->
        <div class="control-group">
            <div class="control-header">
                <span>Turbulence</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="turbulence-toggle" checked>
                    <span class="toggle-slider"></span>
                </label>
            </div>
            <div class="slider-container">
                <input type="range" id="turbulence-slider" class="range-slider" 
                       min="0.1" max="1.0" step="0.1" value="0.5">
                <span class="slider-value">Strength: <span id="turbulence-value">0.5</span></span>
            </div>
        </div>

        <!-- Angular Momentum -->
        <div class="control-group">
            <div class="control-header">
                <span>Angular Momentum</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="angular-momentum-toggle" checked>
                    <span class="toggle-slider"></span>
                </label>
            </div>
            <div class="slider-container">
                <input type="range" id="angular-momentum-slider" class="range-slider" 
                       min="0.001" max="0.01" step="0.001" value="0.003">
                <span class="slider-value">Strength: <span id="angular-momentum-value">0.003</span></span>
            </div>
        </div>

        <!-- Surface Tension -->
        <div class="control-group">
            <div class="control-header">
                <span>Surface Tension</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="surface-tension-toggle" checked>
                    <span class="toggle-slider"></span>
                </label>
            </div>
            <div class="slider-container">
                <input type="range" id="surface-tension-slider" class="range-slider" 
                       min="0.01" max="0.1" step="0.01" value="0.03">
                <span class="slider-value">Strength: <span id="surface-tension-value">0.03</span></span>
            </div>
        </div>
    </div>

    <script>
    function createShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
            return null;
        }
        return shader;
    }
    
    function initWebGL() {
    const canvas = document.getElementById('glcanvas');
    // CRITICAL FOR RENDERING – WebGL context setup
    const gl = canvas.getContext('webgl', { alpha: true });
    if (!gl) {
        alert('Unable to initialize WebGL. Your browser may not support it.');
        return;
    }

    // CRITICAL FOR RENDERING – Clear color and blending setup
    gl.clearColor(0.0, 0.0, 0.0, 0.0); // Fully transparent background
    gl.viewport(0, 0, canvas.width, canvas.height);
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

    
        // CRITICAL FOR RENDERING – Vertex shader (don't modify)
        const vertexShaderSource = `
            attribute vec2 position;
            void main() {
                gl_Position = vec4(position, 0.0, 1.0);
            }
        `;
    
        // CRITICAL FOR RENDERING – Fragment shader (don't modify)
        const fragmentShaderSource = `
        precision highp float;
        uniform float canvasWidth;
        uniform float canvasHeight;
        uniform float time;
        uniform vec2 metaballPositions[3];
        uniform vec2 mousePos;
        uniform float mouseForceEnabled;
        uniform float mouseForceStrength;
        uniform float mouseForceRadius;
        uniform float mouseForceType;
        uniform vec3 baseColor;
        uniform vec3 secondaryColor;
        uniform vec3 backgroundColor;
        uniform float velocityColorEnabled;
        uniform float velocityColorIntensity;
        uniform float distanceColorEnabled;
        uniform float distanceColorIntensity;

        // EFFECT CONTROLS
        // ----------------------------
        const float DAMPING_ENABLED = 0.0;  // 1.0 = on, 0.0 = off
        float dampingFactor = 0.90;         // Increased damping (was 0.95)
                                           // Lower value = stronger damping
                                           // Try values: 0.95 (subtle), 0.80 (medium), 0.60 (strong)

        const float VORTICITY_ENABLED = 0.0;  // 1.0 = on, 0.0 = off
        float vorticityFactor = 0.9;         // Controls strength of the vortex effect
                                            // Try values: 0.2 (subtle), 0.5 (medium), 1.0 (strong)

        const float TURBULENCE_ENABLED = 1.0;  // 1.0 = on, 0.0 = off
        float turbulenceFactor = 0.5;       // Controls strength of the turbulence
                                           // Try values: 0.2 (subtle), 0.5 (medium), 1.0 (strong)

        const float ANGULAR_MOMENTUM_ENABLED = 1.0;  // 1.0 = on, 0.0 = off
        float angularMomentumFactor = 0.003;        // Controls strength of orbital motion
                                                    // Try values: 0.002 (subtle), 0.003 (medium), 0.005 (strong)

        const float SURFACE_TENSION_ENABLED = 1.0;  // 1.0 = on, 0.0 = off
        float surfaceTensionFactor = 0.03;          // Controls strength of surface tension
                                                   // Try values: 0.2 (subtle), 0.3 (medium), 0.5 (strong)

        const float VISCOUS_DAMPING_ENABLED = 1.0;  // 1.0 = on, 0.0 = off
        float viscosityFactor = 0.9;               // Controls strength of viscous damping
                                                    // Try values: 0.99 (subtle), 0.98 (medium), 0.95 (strong)
                                                    // Higher values = less damping

        // Pseudo-random value generator
        float rand(vec2 n) { 
            return fract(sin(dot(n, vec2(12.9898, 78.233))) * 43758.5453);
        }

        // Smooth interpolation function
        float smooth_rand(vec2 n) {
            vec2 i = floor(n);
            vec2 f = fract(n);
            float a = rand(i);
            float b = rand(i + vec2(1.0, 0.0));
            float c = rand(i + vec2(0.0, 1.0));
            float d = rand(i + vec2(1.0, 1.0));
            vec2 u = f * f * (3.0 - 2.0 * f);
            return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
        }

        // Turbulence function using multiple noise octaves
        vec2 turbulence(vec2 pos, float t) {
            if (TURBULENCE_ENABLED <= 0.0) return pos;

            vec2 offset = vec2(0.0);
            float scale = 4.0;  // Increased base scale for more visible effect
            float weight = turbulenceFactor;  // Use turbulenceFactor directly as weight
            
            // Add multiple layers of noise
            for (int i = 0; i < 3; i++) {
                vec2 p = pos * scale + vec2(t * 0.2, t * -0.1);  // Increased time influence
                float noise = smooth_rand(p);
                offset += vec2(
                    cos(noise * 6.28318),
                    sin(noise * 6.28318)
                ) * weight * 0.1;  // Scale the offset by a fixed amount
                
                scale *= 2.0;
                weight *= 0.5;
            }
            
            return pos + offset;
        }

        float metaball(vec2 point, vec2 center, float radius) {
            vec2 aspectRatio = vec2(canvasWidth / canvasHeight, 1.0);
            point.x *= aspectRatio.x;
            center.x *= aspectRatio.x;
            float dx = point.x - center.x;
            float dy = point.y - center.y;
            return radius / (dx * dx + dy * dy);
        }

        vec2 applyVortex(vec2 position, vec2 center, float t) {
            vec2 toCenter = center - position;
            float dist = length(toCenter);
            
            // Normalize distance to control the effect strength
            float normalizedDist = clamp(dist, 0.0, 1.0);
            
            // Make the rotation slower and more controlled
            // Rotation is faster when closer to center, but capped
            float angle = t * vorticityFactor * 0.2 * (1.0 - normalizedDist * 0.8);
            
            // Rotate the position around the center
            float s = sin(angle);
            float c = cos(angle);
            vec2 rotated = vec2(
                toCenter.x * c - toCenter.y * s,
                toCenter.x * s + toCenter.y * c
            );
            
            // Add a small inward pull to maintain the spiral
            float pullStrength = 0.02 * vorticityFactor;
            rotated = rotated * (1.0 - pullStrength);
            
            // Ensure the position stays within bounds
            vec2 newPos = center - rotated;
            return clamp(newPos, vec2(0.0), vec2(1.0));
        }

        vec2 applyAngularMomentum(vec2 position, vec2 center, float t) {
            if (ANGULAR_MOMENTUM_ENABLED <= 0.0) return position;

            vec2 toCenter = center - position;
            float dist = length(toCenter);
            
            // Avoid division by zero and extreme values
            dist = max(dist, 0.1);
            
            // Calculate angular velocity based on distance
            // Closer objects rotate faster
            float angularVelocity = 1.0 / max(dist, 0.1);
            
            // Calculate rotation angle
            float angle = t * angularMomentumFactor * angularVelocity;
            
            // Rotate the position around the center
            float s = sin(angle);
            float c = cos(angle);
            vec2 rotated = vec2(
                toCenter.x * c - toCenter.y * s,
                toCenter.x * s + toCenter.y * c
            );
            
            return center - rotated;
        }

        // Smooth step with adjustable edge based on distance
        float adaptiveSmooth(float edge0, float edge1, float x, float tension) {
            if (SURFACE_TENSION_ENABLED <= 0.0) return smoothstep(edge0, edge1, x);
            
            // Adjust edge sharpness based on tension
            float range = edge1 - edge0;
            // Keep edges closer together for sharper blending
            float adjustedEdge1 = edge1 + (range * tension * 0.2);
            float adjustedEdge0 = edge0 - (range * tension * 0.1);
            return smoothstep(adjustedEdge0, adjustedEdge1, x);
        }

        // Calculate distance between two metaballs
        float metaballDistance(vec2 pos1, vec2 pos2) {
            vec2 aspectRatio = vec2(canvasWidth / canvasHeight, 1.0);
            pos1.x *= aspectRatio.x;
            pos2.x *= aspectRatio.x;
            return length(pos1 - pos2);
        }

        // Calculate velocity-based damping
        vec2 applyViscousDamping(vec2 currentPos, vec2 prevPos) {
            if (VISCOUS_DAMPING_ENABLED <= 0.0) return currentPos;
            
            // Calculate velocity
            vec2 velocity = currentPos - prevPos;
            
            // Apply non-linear damping based on velocity magnitude
            float speed = length(velocity);
            float dampingStrength = mix(1.0, viscosityFactor, smoothstep(0.0, 0.1, speed));
            
            // Apply damping to the movement
            return prevPos + velocity * dampingStrength;
        }

        // Color blending functions
        vec3 blendColors(vec3 color1, vec3 color2, float factor) {
            return mix(color1, color2, factor);
        }

        vec3 getVelocityColor(vec2 position, vec2 prevPosition) {
            if (velocityColorEnabled <= 0.0) return baseColor;
            
            vec2 velocity = position - prevPosition;
            float speed = length(velocity) * 20.0; // Scale for better visual
            float colorFactor = smoothstep(0.0, velocityColorIntensity, speed);
            
            return blendColors(baseColor, secondaryColor, colorFactor);
        }

        vec3 getDistanceColor(vec2 position, float fieldStrength) {
            if (distanceColorEnabled <= 0.0) return baseColor;
            
            float distanceFactor = smoothstep(0.25, 0.27, fieldStrength) * distanceColorIntensity;
            return blendColors(baseColor, secondaryColor, distanceFactor);
        }

        vec2 applyMouseForce(vec2 position) {
            if (mouseForceEnabled <= 0.0) return position;

            vec2 toMouse = mousePos - position;
            float dist = length(toMouse);
            
            // Convert pixel radius to normalized space
            float maxRadius = mouseForceRadius / 500.0;
            
            if (dist < 0.001) return position; // Prevent division by zero
            if (dist > maxRadius) return position;
            
            // Stronger force calculation
            float normalizedDist = dist / maxRadius;
            float forceMagnitude = (1.0 - normalizedDist * normalizedDist) * mouseForceStrength * 0.2;
            
            // Apply force direction (attract or repel)
            return position + normalize(toMouse) * forceMagnitude * mouseForceType;
        }

        void main() {
            vec2 point = gl_FragCoord.xy / vec2(canvasWidth, canvasHeight);
            float sum = 0.0;
            vec2 canvasCenter = vec2(0.5, 0.5);
            float totalTension = 0.0;
            vec3 finalColor = baseColor;
            
            vec2 finalPositions[3];
            vec2 previousPositions[3];

            // First pass: calculate positions
            for (int i = 0; i < 3; i++) {
                float delay = 0.15 * float(i);
                float lerpFactor = (sin(time - delay) + 1.0) / 2.0;
                
                vec2 position = metaballPositions[i];
                vec2 prevPosition = position;

                // Apply mouse force
                position = applyMouseForce(position);
                
                // Apply other effects
                position = turbulence(position, time);
                position = applyAngularMomentum(position, canvasCenter, time);
                if (VORTICITY_ENABLED > 0.0) {
                    position = applyVortex(position, canvasCenter, time);
                }
                
                // Reduced center pull and damping
                lerpFactor *= 0.5;
                position = mix(position, canvasCenter, lerpFactor);
                position = applyViscousDamping(position, prevPosition);
                
                finalPositions[i] = position;
                previousPositions[i] = prevPosition;
            }

            // Second pass: calculate metaball field
            for (int i = 0; i < 3; i++) {
                float fieldStrength = metaball(point, finalPositions[i], 0.003125);
                sum += fieldStrength;

                // Calculate colors
                vec3 velocityBasedColor = getVelocityColor(finalPositions[i], previousPositions[i]);
                vec3 distanceBasedColor = getDistanceColor(finalPositions[i], fieldStrength);
                
                // Blend colors based on field strength
                finalColor = blendColors(
                    finalColor,
                    blendColors(velocityBasedColor, distanceBasedColor, 0.5),
                    fieldStrength / (sum + 0.01)
                );
            }

            float edge0 = 0.25;
            float edge1 = 0.27;
            float alpha = adaptiveSmooth(edge0, edge1, sum, totalTension);
            gl_FragColor = vec4(finalColor, alpha);
        }
        `;

    
        // CRITICAL FOR RENDERING – Shader compilation and linking
        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
    
        // CRITICAL FOR RENDERING – Program creation and linking
        const shaderProgram = gl.createProgram();
        
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        
        gl.linkProgram(shaderProgram);
        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
            return;
        }
        gl.useProgram(shaderProgram);
    
        // CRITICAL FOR RENDERING – Vertex buffer setup
        const vertices = new Float32Array([
            -1.0, -1.0, 1.0, -1.0, -1.0, 1.0,
            -1.0, 1.0, 1.0, -1.0, 1.0, 1.0,
        ]);
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
    
        const positionLocation = gl.getAttribLocation(shaderProgram, 'position');
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
    
        // CRITICAL FOR RENDERING – Uniform locations
        const canvasWidthLocation = gl.getUniformLocation(shaderProgram, 'canvasWidth');
        const canvasHeightLocation = gl.getUniformLocation(shaderProgram, 'canvasHeight');
        gl.uniform1f(canvasWidthLocation, canvas.width);
        gl.uniform1f(canvasHeightLocation, canvas.height);
    
        const timeLocation = gl.getUniformLocation(shaderProgram, 'time');
        let startTime = Date.now();

        // Control uniform locations
        const uniformLocations = {
            viscousDampingEnabled: gl.getUniformLocation(shaderProgram, 'VISCOUS_DAMPING_ENABLED'),
            viscosityFactor: gl.getUniformLocation(shaderProgram, 'viscosityFactor'),
            vorticityEnabled: gl.getUniformLocation(shaderProgram, 'VORTICITY_ENABLED'),
            vorticityFactor: gl.getUniformLocation(shaderProgram, 'vorticityFactor'),
            turbulenceEnabled: gl.getUniformLocation(shaderProgram, 'TURBULENCE_ENABLED'),
            turbulenceFactor: gl.getUniformLocation(shaderProgram, 'turbulenceFactor'),
            angularMomentumEnabled: gl.getUniformLocation(shaderProgram, 'ANGULAR_MOMENTUM_ENABLED'),
            angularMomentumFactor: gl.getUniformLocation(shaderProgram, 'angularMomentumFactor'),
            surfaceTensionEnabled: gl.getUniformLocation(shaderProgram, 'SURFACE_TENSION_ENABLED'),
            surfaceTensionFactor: gl.getUniformLocation(shaderProgram, 'surfaceTensionFactor')
        };

        // Add color uniform locations
        const colorUniforms = {
            baseColor: gl.getUniformLocation(shaderProgram, 'baseColor'),
            secondaryColor: gl.getUniformLocation(shaderProgram, 'secondaryColor'),
            backgroundColor: gl.getUniformLocation(shaderProgram, 'backgroundColor'),
            velocityColorEnabled: gl.getUniformLocation(shaderProgram, 'velocityColorEnabled'),
            velocityColorIntensity: gl.getUniformLocation(shaderProgram, 'velocityColorIntensity'),
            distanceColorEnabled: gl.getUniformLocation(shaderProgram, 'distanceColorEnabled'),
            distanceColorIntensity: gl.getUniformLocation(shaderProgram, 'distanceColorIntensity')
        };

        // Add mouse tracking
        let mouseX = 0;
        let mouseY = 0;
        let isAttracting = true;

        // Update mouse tracking to use canvas coordinates properly
        function updateMousePosition(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            mouseX = ((e.clientX - rect.left) * scaleX) / canvas.width;
            mouseY = 1.0 - ((e.clientY - rect.top) * scaleY) / canvas.height;
            
            gl.uniform2f(gl.getUniformLocation(shaderProgram, 'mousePos'), mouseX, mouseY);
        }

        canvas.addEventListener('mousemove', updateMousePosition);
        canvas.addEventListener('mouseenter', updateMousePosition);

        // Update mouse controls setup
        function setupMouseControls() {
            const attractButton = document.getElementById('attract-button');
            const repelButton = document.getElementById('repel-button');

            document.getElementById('mouse-force-toggle').addEventListener('change', function(e) {
                gl.uniform1f(gl.getUniformLocation(shaderProgram, 'mouseForceEnabled'), e.target.checked ? 1.0 : 0.0);
            });

            document.getElementById('mouse-force-slider').addEventListener('input', function(e) {
                const value = parseFloat(e.target.value);
                gl.uniform1f(gl.getUniformLocation(shaderProgram, 'mouseForceStrength'), value);
                document.getElementById('mouse-force-value').textContent = value.toFixed(1);
            });

            document.getElementById('mouse-radius-slider').addEventListener('input', function(e) {
                const value = parseFloat(e.target.value);
                gl.uniform1f(gl.getUniformLocation(shaderProgram, 'mouseForceRadius'), value);
                document.getElementById('mouse-radius-value').textContent = value;
            });

            attractButton.addEventListener('click', function() {
                isAttracting = true;
                gl.uniform1f(gl.getUniformLocation(shaderProgram, 'mouseForceType'), 1.0);
                attractButton.classList.add('active');
                repelButton.classList.remove('active');
            });

            repelButton.addEventListener('click', function() {
                isAttracting = false;
                gl.uniform1f(gl.getUniformLocation(shaderProgram, 'mouseForceType'), -1.0);
                repelButton.classList.add('active');
                attractButton.classList.remove('active');
            });
        }

        // Initialize mouse controls with stronger default values
        setupMouseControls();
        gl.uniform2f(gl.getUniformLocation(shaderProgram, 'mousePos'), 0.5, 0.5);
        gl.uniform1f(gl.getUniformLocation(shaderProgram, 'mouseForceEnabled'), document.getElementById('mouse-force-toggle').checked ? 1.0 : 0.0);
        gl.uniform1f(gl.getUniformLocation(shaderProgram, 'mouseForceStrength'), 1.5); // Increased default strength
        gl.uniform1f(gl.getUniformLocation(shaderProgram, 'mouseForceRadius'), 200.0); // Increased default radius
        gl.uniform1f(gl.getUniformLocation(shaderProgram, 'mouseForceType'), 1.0);

        // Update mouse force slider default
        document.getElementById('mouse-force-slider').value = 1.5;
        document.getElementById('mouse-force-value').textContent = '1.5';
        
        // Update radius slider default
        document.getElementById('mouse-radius-slider').value = 200;
        document.getElementById('mouse-radius-value').textContent = '200';

        // Control event listeners
        function setupControlListeners() {
            // Viscous Damping
            document.getElementById('viscous-damping-toggle').addEventListener('change', function(e) {
                gl.uniform1f(uniformLocations.viscousDampingEnabled, e.target.checked ? 1.0 : 0.0);
            });
            document.getElementById('viscous-damping-slider').addEventListener('input', function(e) {
                const value = parseFloat(e.target.value);
                gl.uniform1f(uniformLocations.viscosityFactor, value);
                document.getElementById('viscous-damping-value').textContent = value.toFixed(2);
            });

            // Vorticity
            document.getElementById('vorticity-toggle').addEventListener('change', function(e) {
                gl.uniform1f(uniformLocations.vorticityEnabled, e.target.checked ? 1.0 : 0.0);
            });
            document.getElementById('vorticity-slider').addEventListener('input', function(e) {
                const value = parseFloat(e.target.value);
                gl.uniform1f(uniformLocations.vorticityFactor, value);
                document.getElementById('vorticity-value').textContent = value.toFixed(2);
            });

            // Turbulence
            document.getElementById('turbulence-toggle').addEventListener('change', function(e) {
                gl.uniform1f(uniformLocations.turbulenceEnabled, e.target.checked ? 1.0 : 0.0);
            });
            document.getElementById('turbulence-slider').addEventListener('input', function(e) {
                const value = parseFloat(e.target.value);
                gl.uniform1f(uniformLocations.turbulenceFactor, value);
                document.getElementById('turbulence-value').textContent = value.toFixed(2);
            });

            // Angular Momentum
            document.getElementById('angular-momentum-toggle').addEventListener('change', function(e) {
                gl.uniform1f(uniformLocations.angularMomentumEnabled, e.target.checked ? 1.0 : 0.0);
            });
            document.getElementById('angular-momentum-slider').addEventListener('input', function(e) {
                const value = parseFloat(e.target.value);
                gl.uniform1f(uniformLocations.angularMomentumFactor, value);
                document.getElementById('angular-momentum-value').textContent = value.toFixed(3);
            });

            // Surface Tension
            document.getElementById('surface-tension-toggle').addEventListener('change', function(e) {
                gl.uniform1f(uniformLocations.surfaceTensionEnabled, e.target.checked ? 1.0 : 0.0);
            });
            document.getElementById('surface-tension-slider').addEventListener('input', function(e) {
                const value = parseFloat(e.target.value);
                gl.uniform1f(uniformLocations.surfaceTensionFactor, value);
                document.getElementById('surface-tension-value').textContent = value.toFixed(2);
            });
        }

        // Add color control listeners
        function setupColorControls() {
            // Base Color
            document.getElementById('base-color').addEventListener('input', function(e) {
                const rgb = hexToRGB(e.target.value);
                gl.uniform3fv(colorUniforms.baseColor, rgb);
            });

            // Secondary Color
            document.getElementById('secondary-color').addEventListener('input', function(e) {
                const rgb = hexToRGB(e.target.value);
                gl.uniform3fv(colorUniforms.secondaryColor, rgb);
            });

            // Background Color
            document.getElementById('background-color').addEventListener('input', function(e) {
                const rgb = hexToRGB(e.target.value);
                gl.uniform3fv(colorUniforms.backgroundColor, rgb);
                canvas.style.backgroundColor = e.target.value;
            });

            // Velocity Color
            document.getElementById('velocity-color-toggle').addEventListener('change', function(e) {
                gl.uniform1f(colorUniforms.velocityColorEnabled, e.target.checked ? 1.0 : 0.0);
            });
            document.getElementById('velocity-color-slider').addEventListener('input', function(e) {
                const value = parseFloat(e.target.value);
                gl.uniform1f(colorUniforms.velocityColorIntensity, value);
                document.getElementById('velocity-color-value').textContent = value.toFixed(1);
            });

            // Distance Color
            document.getElementById('distance-color-toggle').addEventListener('change', function(e) {
                gl.uniform1f(colorUniforms.distanceColorEnabled, e.target.checked ? 1.0 : 0.0);
            });
            document.getElementById('distance-color-slider').addEventListener('input', function(e) {
                const value = parseFloat(e.target.value);
                gl.uniform1f(colorUniforms.distanceColorIntensity, value);
                document.getElementById('distance-color-value').textContent = value.toFixed(1);
            });
        }

        // Initialize controls
        setupControlListeners();
        setupColorControls();

        // Set initial uniform values
        gl.uniform1f(uniformLocations.viscousDampingEnabled, document.getElementById('viscous-damping-toggle').checked ? 1.0 : 0.0);
        gl.uniform1f(uniformLocations.viscosityFactor, parseFloat(document.getElementById('viscous-damping-slider').value));
        gl.uniform1f(uniformLocations.vorticityEnabled, document.getElementById('vorticity-toggle').checked ? 1.0 : 0.0);
        gl.uniform1f(uniformLocations.vorticityFactor, parseFloat(document.getElementById('vorticity-slider').value));
        gl.uniform1f(uniformLocations.turbulenceEnabled, document.getElementById('turbulence-toggle').checked ? 1.0 : 0.0);
        gl.uniform1f(uniformLocations.turbulenceFactor, parseFloat(document.getElementById('turbulence-slider').value));
        gl.uniform1f(uniformLocations.angularMomentumEnabled, document.getElementById('angular-momentum-toggle').checked ? 1.0 : 0.0);
        gl.uniform1f(uniformLocations.angularMomentumFactor, parseFloat(document.getElementById('angular-momentum-slider').value));
        gl.uniform1f(uniformLocations.surfaceTensionEnabled, document.getElementById('surface-tension-toggle').checked ? 1.0 : 0.0);
        gl.uniform1f(uniformLocations.surfaceTensionFactor, parseFloat(document.getElementById('surface-tension-slider').value));

        // Add color initial uniform values
        gl.uniform3fv(colorUniforms.baseColor, hexToRGB(document.getElementById('base-color').value));
        gl.uniform3fv(colorUniforms.secondaryColor, hexToRGB(document.getElementById('secondary-color').value));
        gl.uniform3fv(colorUniforms.backgroundColor, hexToRGB(document.getElementById('background-color').value));
        gl.uniform1f(colorUniforms.velocityColorEnabled, document.getElementById('velocity-color-toggle').checked ? 1.0 : 0.0);
        gl.uniform1f(colorUniforms.velocityColorIntensity, parseFloat(document.getElementById('velocity-color-slider').value));
        gl.uniform1f(colorUniforms.distanceColorEnabled, document.getElementById('distance-color-toggle').checked ? 1.0 : 0.0);
        gl.uniform1f(colorUniforms.distanceColorIntensity, parseFloat(document.getElementById('distance-color-slider').value));

        // Maximum number of metaballs we'll support
        const maxMetaballs = 3; // Changed from 9 to 3

        // ✅ SAFE TO MODIFY – Calculate and update metaball positions in JavaScript
        function updateMetaballPositions(currentTime) {
            const metaballPositions = [];
            
            // SPREAD CONTROL
            // -------------
            // radius: Controls how far apart the metaballs are in their circular arrangement
            // Current value: 0.75 for large spread
            // - Decrease to keep metaballs closer together (try 0.4)
            // - Increase to spread them further apart
            // Note: This works with the field strength in the shader (0.003125)
            // If you change one, you might need to adjust the other
            const radius = 0.4; // Reduced from 0.75 to keep balls closer together

            for (let i = 0; i < maxMetaballs; i++) {
                const angle = (i / maxMetaballs) * Math.PI * 2;
                metaballPositions.push(Math.cos(angle) * radius + 0.5);
                metaballPositions.push(Math.sin(angle) * radius + 0.5);
            }
            return metaballPositions;
        }
    
        // ✅ SAFE TO MODIFY – Animation loop (this is where you control movement)
        function animate() {
            let currentTime = ((Date.now() - startTime) / 1000.0) * 2; // Speed factor of 2

            gl.uniform1f(timeLocation, currentTime);
            
            const metaballPositions = updateMetaballPositions(currentTime);
            // CRITICAL FOR RENDERING – Pass positions to shader
            for (let i = 0; i < maxMetaballs; i++) {
                const uniformLocation = gl.getUniformLocation(shaderProgram, `metaballPositions[${i}]`);
                gl.uniform2fv(uniformLocation, metaballPositions.slice(i * 2, i * 2 + 2));
            }
            
            draw();
            requestAnimationFrame(animate);
        }
    
        // CRITICAL FOR RENDERING – Draw function
        function draw() {
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.drawArrays(gl.TRIANGLES, 0, 6);
        }
    
        animate();
    }
    
    window.onload = initWebGL;

    // Helper function to convert hex to RGB
    function hexToRGB(hex) {
        const r = parseInt(hex.slice(1, 3), 16) / 255;
        const g = parseInt(hex.slice(3, 5), 16) / 255;
        const b = parseInt(hex.slice(5, 7), 16) / 255;
        return [r, g, b];
    }
    </script>
    
</body>
</html>


